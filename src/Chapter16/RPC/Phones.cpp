#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include "phone.h"    // Header file generated by MIDL compiler

BOOL IsLRPC(void *ctx) {
	BOOL fAllowProtocol = FALSE;
	LPBYTE pBinding = NULL;

	if (RpcBindingToStringBinding(ctx,&pBinding) == RPC_S_OK) {

		LPBYTE  pProtSeq = NULL;
                // We're only interested in the protocol sequence
                // so we can use NULL for all other parameters.

		if (RpcStringBindingParse(pBinding,
									NULL,
									&pProtSeq,
									NULL,
									NULL,
									NULL) == RPC_S_OK) {
			printf("Using %s\n",pProtSeq);
			
			// Check that the client request 
                        // was made using LRPC.
			if (lstrcmpi((LPCTSTR)pProtSeq,"ncalrpc") == 0)
				fAllowProtocol = TRUE;

			if (pProtSeq)	
				RpcStringFree(&pProtSeq); 
		}

		if (pBinding)	
			RpcStringFree(&pBinding);
	}

	return fAllowProtocol;
}

RPC_STATUS RPC_ENTRY SecurityCallBack(RPC_IF_HANDLE idIF, void *ctx) {
	
	// Only allow LRPC traffic (commented out!)
	//if (!IsLRPC(ctx)) 
	//	RpcRaiseException(ERROR_PROTOCOL_UNREACHABLE);

	RPC_AUTHZ_HANDLE hPrivs;
	DWORD dwAuthn;

	RPC_STATUS status = RpcBindingInqAuthClient(
			ctx,
			&hPrivs,
			NULL,
			&dwAuthn,
			NULL,
			NULL);
										
	if (status != RPC_S_OK) {
		printf("RpcBindingInqAuthClient returned: 0x%x\n", status);
		RpcRaiseException(ERROR_ACCESS_DENIED);
	}

	// Now check the authentication level.
	// We require at least packet-level authentication.
	if (dwAuthn < RPC_C_AUTHN_LEVEL_PKT) {
		printf("Attempt by client to use weak authentication.\n");
		RpcRaiseException(ERROR_ACCESS_DENIED);
	}

	return RPC_S_OK;
}

void Usage() {
    fprintf(stderr, "Usage:  Phones\n");
    fprintf(stderr, " -p protocol_sequence\n");
    fprintf(stderr, " -e endpoint\n");
    fprintf(stderr, " -m maxcalls\n");
    fprintf(stderr, " -n mincalls\n");
    fprintf(stderr, " -f flag_wait_op\n");
    exit(1);
}

void __cdecl main(int argc, char *argv[]) {
	LPBYTE pszProtocolSequence = (LPBYTE)"ncacn_np";
    LPBYTE pszSecurity         = (LPBYTE)NULL;
    LPBYTE pszEndpoint         = (LPBYTE)"\\pipe\\phone";
    unsigned int cMinCalls     = 1;
    unsigned int cMaxCalls     = 20;
    unsigned int fDontWait     = FALSE;

    // Allow the user to override settings with command line switches. 
    for (int i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'p':  
                pszProtocolSequence = (LPBYTE)argv[++i];
                break;
            case 'e':
                pszEndpoint = (LPBYTE)argv[++i];
                break;
            case 'm':
                cMaxCalls = (unsigned int) atoi(argv[++i]);
                break;
            case 'n':
                cMinCalls = (unsigned int) atoi(argv[++i]);
                break;
            case 'f':
                fDontWait = (unsigned int) atoi(argv[++i]);
                break;
            case 'h':
            case '?':
            default:
                Usage();
            }
        }
        else
            Usage();
    }

    RPC_STATUS status = RpcServerUseProtseqEp(pszProtocolSequence,
                                   cMaxCalls,
                                   pszEndpoint,
                                   pszSecurity);  
    printf("RpcServerUseProtseqEp returned 0x%x\n", status);
    if (status)
        exit(status);

    status = RpcServerRegisterIfEx(phone_v1_0_s_ifspec,   
                                 NULL,
								 NULL,
								 0,
								 RPC_C_LISTEN_MAX_CALLS_DEFAULT,
								 SecurityCallBack);  
    printf("RpcServerRegisterIfEx returned 0x%x\n", status);
    if (status)
        exit(status);

	LPBYTE szSPN = NULL;
	status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE,
										&szSPN);
    printf("RpcServerInqDefaultPrincName returned 0x%x (%s)\n", status,szSPN);
    if (status)
        exit(status);

	status = RpcServerRegisterAuthInfo(szSPN,
                                       RPC_C_AUTHN_GSS_NEGOTIATE,
                                       0,
                                       0);
    printf("RpcServerRegisterAuthInfo returned 0x%x\n", status);
	if (status)
      exit(status);

	RPC_BINDING_VECTOR *pBindings = NULL;
	status = RpcServerInqBindings(&pBindings);
    printf("RpcServerInqBindings returned 0x%x\n", status);
	if (status)
      exit(status);

	status = RpcEpRegister(phone_v1_0_s_ifspec,
							pBindings,
						   NULL,
						   (LPBYTE)"Phone Application");
    printf("RpcEpRegister returned 0x%x\n", status);
	if (status)
      exit(status);

    printf("Calling RpcServerListen\n");
    status = RpcServerListen(cMinCalls,
                             cMaxCalls,
                             fDontWait);
    printf("RpcServerListen returned: 0x%x\n", status);
    if (status) 
        exit(status);

    if (fDontWait) {
        printf("Calling RpcMgmtWaitServerListen\n");
        status = RpcMgmtWaitServerListen();  
        printf("RpcMgmtWaitServerListen returned: 0x%x\n", status);
       
		if (status) 
            exit(status);
    }

	if (szSPN)
		RpcStringFree(&szSPN);
}  

// The remote function, Message
void Message(handle_t hPhone, unsigned char *szMsg) {

	if (RpcImpersonateClient(hPhone) != RPC_S_OK) {
		printf("Impersonation failed.\n");
		RpcRaiseException(ERROR_ACCESS_DENIED);
	}

	char szName[128+1];
	DWORD dwNameLen = 128;
	if (!GetUserName(szName,&dwNameLen))
		lstrcpy(szName,"Unknown user");

	printf("The message from %s is: %s\n", 
		   szName,szMsg);

	RpcRevertToSelf();
}

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len) {
    return(malloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr) {
    free(ptr);
}
